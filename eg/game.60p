assign byte[256] screen $0400
assign byte[256] screen2 1274
assign byte[256] screen3 1524
assign byte[256] screen4 1774

assign byte[256] colormap 55296
assign byte[256] colormap2 55546
assign byte[256] colormap3 55796
assign byte[256] colormap4 56046

assign byte vic_border 53280
assign byte[4] vic_bg 53281

assign byte joy2 $dc00

assign vector cinv 788

/* --------- */

reserve vector save_cinv

assign word position $fb
assign word new_position $fd

reserve word delta
reserve byte value
reserve word compare_target

reserve word[16] actor_pos

reserve vector dispatch_state
reserve vector dispatch_logic

reserve byte[18] press_fire_msg: "PRESS`FIRE`TO`PLAY"

routine calculate_new_position outputs (new_position) {
    clc
    lda <position
    adc <delta
    sta <new_position
    lda >position
    adc >delta
    sta >new_position
}

routine compare_new_pos {
    lda >new_position
    cmp >compare_target
    if beq {
        lda <new_position
        cmp <compare_target
    } else {
    }
}

routine check_new_position_in_bounds {
    copy #$07e8 compare_target      // just past bottom of screen
    jsr compare_new_pos

    if bcs {
        clc
    } else {

        copy #$0400 compare_target
        jsr compare_new_pos

        if bcc {
            clc
        } else {
            sec
        }
    }
}

routine clear_screen {
    ldy #0
    repeat bne {
        lda #1
        sta colormap, y
        sta colormap2, y
        sta colormap3, y
        sta colormap4, y
        
        lda #32
        sta screen, y
        sta screen2, y
        sta screen3, y
        sta screen4, y

        iny
        cpy #250
    }
}

routine read_stick {
    lda #0
    sta <delta
    sta >delta
    ldx joy2
    txa
    and #1                   // up
    if beq {
        lda #216             // -40
        sta <delta
        lda #255
        sta >delta
    } else {
        txa
        and #2               // down
        if beq {
            lda #40
            sta <delta
        } else {
            txa
            and #4           // left
            if beq {
                lda #255     // -1
                sta <delta
                sta >delta
            } else {
                txa
                and #8       // right
                if beq {
                    lda #1
                    sta <delta
                } else { }
            }
        }
    }
}

// output is .z flag
routine check_fire {
    ldx joy2
    txa
    and #16
}

routine init_game {
    // this shouldn't be needed!
    reserve byte temp_a
    ldy #0
    repeat bne {
        lda #$04
        sta temp_a
        copy temp_a >actor_pos, y
        tya
        clc
        asl .a
        asl .a
        sta temp_a
        copy temp_a <actor_pos, y
        iny
        cpy #8
    }
}

routine state_title_screen {
    ldy #0
    repeat bne {
        lda press_fire_msg, y
        sec
        sbc #64   // yuck
        sta screen, y
        iny
        cpy #18
    }
    jsr check_fire
    if beq {
        jsr clear_screen
        jsr init_game
        copy routine state_play_game to dispatch_state
    } else { }
    jmp (save_cinv)
}

routine logic_player {
    jsr read_stick
    jsr calculate_new_position
    jsr check_new_position_in_bounds
    if bcs {
        lda #32
        ldy #0
        sta (position), y
        copy new_position position
        lda #81
        ldy #0
        sta (position), y
    } else { }
}

routine logic_obstacle {
    lda #0
    sta >delta
    lda #1
    sta <delta
    jsr calculate_new_position
    jsr check_new_position_in_bounds
    if bcs {
        lda #32
        ldy #0
        sta (position), y
        copy new_position position
        lda #82
        ldy #0
        sta (position), y
    } else { }
}

routine indirect_jsr_logic {
    jmp (dispatch_logic)
}

routine state_play_game {
    reserve byte save_x
    ldx #0
    repeat bne {
        stx save_x

        copy actor_pos, x position

        cpx #0
        if beq {
            copy routine logic_player to dispatch_logic
        } else {
            copy routine logic_obstacle to dispatch_logic
        }
        jsr indirect_jsr_logic

        ldx save_x
        copy position actor_pos, x

        inx
        cpx #8
    }
    jmp (save_cinv)
}

routine our_cinv {
    jmp (dispatch_state)
}

routine main {
    lda #5
    sta vic_border
    lda #0
    sta vic_bg

    jsr clear_screen
    copy routine state_title_screen to dispatch_state

    with sei {
        copy cinv save_cinv
        copy routine our_cinv to cinv
    }
    clc
    repeat bcc { }
}
