// ****************************
// * Demo Game for SixtyPical *
// ****************************

// ----------------------------------------------------------------
// System Locations
// ----------------------------------------------------------------

byte vic_border @ 53280
byte vic_bg @ 53281

byte table screen1 @ 1024
byte table screen2 @ 1274
byte table screen3 @ 1524
byte table screen4 @ 1774

byte table colormap1 @ 55296
byte table colormap2 @ 55546
byte table colormap3 @ 55796
byte table colormap4 @ 56046

buffer[2048] screen @ 1024
byte joy2 @ $dc00

// ----------------------------------------------------------------
// Global Variables
// ----------------------------------------------------------------

pointer ptr @ 254

word table actor_pos
word pos

word table actor_delta
word delta

byte button_down : 0  // effectively static-local to check_button
byte table press_fire_msg: "PRESS`FIRE`TO`PLAY"

byte save_x

//
// Points to the routine that implements the current game state.
//
// It's very arguable that screen1/2/3/4 and colormap1/2/3/4 are not REALLY inputs.
// They're only there to support the fact that game states sometimes clear the
// screen, and sometimes don't.  When they don't, they preserve the screen, and
// currently the way to say "we preserve the screen" is to have it as both input
// and output.  There is probably a better way to do this, but it needs thought.
//

vector dispatch_game_state
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr

//
// The constraints on these 2 vectors are kind-of sort-of big fibs.
// They're only written this way so they can be compatible with our
// routine.  In fact, CINV is an interrupt routine where it doesn't
// really matter what you trash anyway, because all registers were
/// saved by the caller (the KERNAL) and will be restored by the end
// of the code of the saved origin cinv routine that we goto.
//
// I wonder if this could be arranged somehow to be less fibby, in
// a future version of SixtyPical.
//

vector cinv
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr
  @ 788

vector save_cinv
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr

// ----------------------------------------------------------------
// Utility Routines
// ----------------------------------------------------------------

routine read_stick
  inputs joy2
  outputs delta
  trashes a, x, z, n
{
    ld x, joy2
    ld a, x
    and a, 1                   // up
    if z {
        copy $ffd8, delta      // -40
    } else {
        ld a, x
        and a, 2               // down
        if z {
            copy word 40, delta
        } else {
            ld a, x
            and a, 4               // left
            if z {
                copy $ffff, delta  // -1
            } else {
                ld a, x
                and a, 8           // right
                if z {
                    copy word 1, delta
                } else {
                    copy word 0, delta
                }
            }
        }
    }
}

// You can repeatedly (i.e. as part of actor logic or an IRQ handler)
// call this routine.
// Upon return, if carry is set, the button was pressed then released.

routine check_button
  inputs joy2, button_down
  outputs c, button_down
  trashes a, z, n
{
    ld a, button_down
    if z {
        ld a, joy2
        and a, $10
        if z {
            ld a, 1
            st a, button_down
        }
        st off, c
    } else {
        ld a, joy2
        and a, $10
        if not z {
            ld a, 0
            st a, button_down
            st on, c
        } else {
            st off, c
        }
    }
}

routine clear_screen
  outputs screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, y, c, n, z
{
    ld y, 0
    repeat {
        ld a, 1
        st a, colormap1 + y
        st a, colormap2 + y
        st a, colormap3 + y
        st a, colormap4 + y

        ld a, 32
        st a, screen1 + y
        st a, screen2 + y
        st a, screen3 + y
        st a, screen4 + y

        inc y
        cmp y, 250
    } until z
}

// ----------------------------------------------------------------
// Actor Logics
// ----------------------------------------------------------------

routine player_logic
  inputs pos, delta, joy2, screen
  outputs pos, delta, screen
  trashes a, x, y, c, z, n, v, ptr
{
    call read_stick

    st off, c
    add pos, delta

    copy ^screen, ptr
    st off, c
    add ptr, pos

    ld y, 0
    copy 81, [ptr] + y
}

routine enemy_logic
  inputs pos, delta, joy2, screen
  outputs pos, delta, screen
  trashes a, x, y, c, z, n, v, ptr
{
}

// ----------------------------------------------------------------
// Game States
// ----------------------------------------------------------------

//
// Because these all `goto save_cinv` at the end, they must have the same signature as that routine.
//

routine game_state_play
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr
{
    ld x, 0
    repeat {
        copy actor_pos + x, pos
        copy actor_delta + x, delta

        st x, save_x

        ////// FIXME need VECTOR TABLEs to make this happen:
        ////// copy actor_logic, x dispatch_logic
        ////// call indirect_jsr_logic

        cmp x, 0
        if z {
            call player_logic
        } else {
            call enemy_logic
        }

        ld x, save_x

        copy pos, actor_pos + x
        copy delta, actor_delta + x

        inc x
        cmp x, 16
    } until z

    goto save_cinv
}

routine game_state_title_screen
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr
{
    ld y, 0
    repeat {
        ld a, press_fire_msg + y

        st on, c
        sub a, 64   // yuck.  oh well

        st a, screen1 + y
        inc y
        cmp y, 18
    } until z

    st off, c
    call check_button

    if c {
        call clear_screen
        // call init_game
        copy game_state_play, dispatch_game_state
        ld a, 0   // FIXME we shouldn't need to.
        ld y, 0   // FIXME we shouldn't need to.
        st off, c // FIXME we shouldn't need to.
    } else {
        ld a, 0   // FIXME we shouldn't need to.
    }

    goto save_cinv
}

// *************************
// * Main Game Loop Driver *
// *************************

routine our_cinv
  inputs joy2, button_down, press_fire_msg, dispatch_game_state, save_x,
         actor_pos, pos, actor_delta, delta,
         screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  outputs button_down, dispatch_game_state, save_x,
          actor_pos, pos, actor_delta, delta,
          screen, screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, x, y, c, z, n, v, ptr
{
    goto dispatch_game_state
}

routine main
  inputs cinv
  outputs cinv, save_cinv, pos, dispatch_game_state,
          screen1, screen2, screen3, screen4, colormap1, colormap2, colormap3, colormap4
  trashes a, y, n, c, z, vic_border, vic_bg
{
    ld a, 5
    st a, vic_border
    ld a, 0
    st a, vic_bg
    ld y, 0

    call clear_screen

    copy game_state_title_screen, dispatch_game_state

    copy word 0, pos
    with interrupts off {
        copy cinv, save_cinv
        copy our_cinv, cinv
    }

    repeat { } forever
}
